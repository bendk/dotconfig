#!/usr/bin/python3

from pathlib import Path
import argparse
import os
import shutil
import subprocess
import sys

def xdg_path(env_key, default_home_subdir):
    if os.environ.get(env_key):
        return Path(os.environ[env_key])
    else:
        return Path.home() / Path(default_home_subdir)

XDG_DATA_HOME = xdg_path('XDG_DATA_HOME', '.local/share')
XDG_CONFIG_HOME = xdg_path('XDG_CONFIG_HOME', '.config')

CONFIG_PATH = XDG_CONFIG_HOME / 'nvim/packages.txt'
PACKAGE_ROOT = XDG_DATA_HOME / 'nvim/site/pack/update-packages'
START_DIR = PACKAGE_ROOT / 'start'
OPT_DIR = PACKAGE_ROOT / 'opt'

class Package:
    """
    Represents a package to install
    """
    def __init__(self, source):
        self.source = source
        self.name = self.source.split('/')[-1]

    @classmethod
    def from_config_line(cls, line):
        return cls(
            source=line.strip(),
        )

    def repo_url(self):
        return 'https://github.com/{}'.format(self.source)

    def plugin_path(self):
        return START_DIR / self.name

    def is_present(self):
        return self.plugin_path().exists()

    def clone(self):
        subprocess.check_call(['git', 'clone', self.repo_url(), self.plugin_path()], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    def upgrade(self):
        starting_commit = self.commit_id()
        try:
            subprocess.check_call(['git', 'pull'], cwd=self.plugin_path(), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except subprocess.CalledProcessError:
            print("Error upgrading {}".format(self.name))

        ending_commit = self.commit_id()
        if ending_commit != starting_commit:
            print('upgraded {} ({} -> {})'.format(self.name, starting_commit, ending_commit))

    def commit_id(self):
        return subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD'], cwd=self.plugin_path()).decode('utf8').strip()

    def __eq__(self, other):
        return isinstance(other, Package) and self.name == other.name

    def __str__(self):
        if self.is_present():
            return '{:60} ({})'.format(self.source, self.commit_id())
        else:
            return '{:60} (not checked out)'.format(self.source)

def ensure_dirs():
    os.makedirs(START_DIR, exist_ok=True)
    os.makedirs(OPT_DIR, exist_ok=True)

def read_packages():
    with open(CONFIG_PATH) as f:
        return [
            Package.from_config_line(l)
            for l in f
            if l.strip() and not l.startswith('#')
        ]

def calc_other_dirs(packages):
    package_dirs = set(p.plugin_path() for p in packages)
    return [
        dir
        for dir in START_DIR.iterdir()
        if dir not in package_dirs
    ]

def update_packages(packages, other_dirs, args):
    did_something = False

    for package in packages:
        if not package.is_present():
            print('adding ', package.name)
            package.clone()
            did_something = True
        elif args.upgrade:
            package.upgrade()
            did_something = True

    for dir in other_dirs:
        if args.remove:
            print('removing ', dir)
            if dir.is_symlink():
                dir.unlink()
            else:
                shutil.rmtree(dir)
            did_something = True
        else:
            print('extra directory: {}'.format(dir.name))
    if did_something:
        update_help_tags()

    if other_dirs and not args.remove:
        print()
        print('use --remove to remove extra directories')

def update_help_tags():
    print('updating help tags')
    subprocess.check_call(['nvim', '-c', 'helptags ALL', '-c', 'q!'])

def print_status(packages, other_dirs):
    for package in packages:
        print(package)

    for dir in other_dirs:
        print('{:60} (needs-remove)', dir.name)

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('--upgrade', action='store_true')
    parser.add_argument('--remove', action='store_true')
    parser.add_argument('--status', action='store_true')
    return parser.parse_args()

if __name__ == '__main__':
    args = parse_args()
    ensure_dirs()
    packages = read_packages()
    other_dirs = calc_other_dirs(packages)
    if args.status:
        print_status(packages, other_dirs)
    else:
        update_packages(packages, other_dirs, args)
