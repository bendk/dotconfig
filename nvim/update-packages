#!/usr/bin/python3

from pathlib import Path
import argparse
import os
import shutil
import subprocess
import sys

def xdg_path(env_key, default_home_subdir):
    if os.environ.get(env_key):
        return Path(os.environ[env_key])
    else:
        return Path.home() / Path(default_home_subdir)

XDG_DATA_HOME = xdg_path('XDG_DATA_HOME', '.local/share')
XDG_CONFIG_HOME = xdg_path('XDG_CONFIG_HOME', '.config')

CONFIG_PATH = XDG_CONFIG_HOME / 'nvim/packages.txt'
PACKAGE_ROOT = XDG_DATA_HOME / 'nvim/site/pack/update-packages'
START_DIR = PACKAGE_ROOT / 'start'
OPT_DIR = PACKAGE_ROOT / 'opt'

class Package:
    """
    Represents a package to install
    """
    def __init__(self, source):
        self.source = source
        self.name = self.source.split('/')[-1]

    @classmethod
    def from_config_line(cls, line):
        return cls(
            source=line.strip(),
        )

    def repo_url(self):
        return 'https://github.com/{}'.format(self.source)

    def plugin_path(self):
        return START_DIR / self.name

    def is_present(self):
        return self.plugin_path().exists()

    def clone(self):
        subprocess.check_call(['git', 'clone', self.repo_url(), self.plugin_path()], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    def pull(self):
        subprocess.check_call(['git', 'pull'], cwd=self.plugin_path(), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    def commit_id(self):
        return subprocess.check_output(['git', 'rev-parse', 'HEAD'], cwd=self.plugin_path()).decode('utf8').strip()

    def __eq__(self, other):
        return isinstance(other, Package) and self.name == other.name

    def __str__(self):
        if self.is_present():
            return '{:60} ({})'.format(self.source, self.commit_id())
        else:
            return '{:60} (not checked out)'.format(self.source)

def ensure_dirs():
    os.makedirs(START_DIR, exist_ok=True)
    os.makedirs(OPT_DIR, exist_ok=True)

def read_packages():
    with open(CONFIG_PATH) as f:
        return [
            Package.from_config_line(l)
            for l in f
            if l.strip() and not l.startswith('#')
        ]

def calc_other_dirs(packages):
    package_dirs = set(p.plugin_path() for p in packages)
    return [
        dir
        for dir in START_DIR.iterdir()
        if dir not in package_dirs
    ]

def update_packages(packages, other_dirs, args):
    for package in packages:
        if not package.is_present():
            print('adding ', package.name)
            package.clone()
        elif args.upgrade:
            print('upgrading ', package.name)
            package.pull()

    for dir in other_dirs:
        print('removing ', dir)
        shutil.rmtree(dir)

def print_status(packages, other_dirs):
    for package in packages:
        print(package)

    for dir in other_dirs:
        print('{:60} (needs-remove)', dir.name)

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('--upgrade', action='store_true')
    parser.add_argument('--status', action='store_true')
    return parser.parse_args()

if __name__ == '__main__':
    args = parse_args()
    ensure_dirs()
    packages = read_packages()
    other_dirs = calc_other_dirs(packages)
    if args.status:
        print_status(packages, other_dirs)
    else:
        update_packages(packages, other_dirs, args)
